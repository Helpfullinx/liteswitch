#define TESLA_INIT_IMPL
#include <tesla.hpp>
#include <switch.h>
#include <cstring>
#include <cstdio>

// Configuration paths
const char* CONFIG_DIR = "sdmc:/config/led-control";
const char* CONFIG_FILE = "sdmc:/config/led-control/config.txt";
const char* RELOAD_TRIGGER = "sdmc:/config/led-control/reload";

// Current settings
enum class LEDMode {
    Off,
    Solid,
    Pulse
};

struct LEDSettings {
    LEDMode mode = LEDMode::Off;
    float brightness = 1.0f;
    u64 pulseInterval = 500;
    u32 pulseCount = 0;
};

static LEDSettings g_settings;

// Helper functions
void ensureConfigDirExists() {
    mkdir("sdmc:/config", 0777);
    mkdir(CONFIG_DIR, 0777);
}

bool loadSettings() {
    FILE* file = fopen(CONFIG_FILE, "r");
    if (!file) return false;
    
    char line[256];
    while (fgets(line, sizeof(line), file)) {
        if (line[0] == '#' || line[0] == '\n') continue;
        
        char* equals = strchr(line, '=');
        if (!equals) continue;
        
        *equals = '\0';
        char* key = line;
        char* value = equals + 1;
        
        char* newline = strchr(value, '\n');
        if (newline) *newline = '\0';
        
        if (strcmp(key, "mode") == 0) {
            if (strcmp(value, "off") == 0) g_settings.mode = LEDMode::Off;
            else if (strcmp(value, "solid") == 0) g_settings.mode = LEDMode::Solid;
            else if (strcmp(value, "pulse") == 0) g_settings.mode = LEDMode::Pulse;
        }
        else if (strcmp(key, "brightness") == 0) {
            g_settings.brightness = atof(value);
        }
        else if (strcmp(key, "pulse_interval") == 0) {
            g_settings.pulseInterval = atoi(value);
        }
        else if (strcmp(key, "pulse_count") == 0) {
            g_settings.pulseCount = atoi(value);
        }
    }
    
    fclose(file);
    return true;
}

bool saveSettings() {
    ensureConfigDirExists();
    
    FILE* file = fopen(CONFIG_FILE, "w");
    if (!file) return false;
    
    fprintf(file, "# LED Control Configuration\n");
    fprintf(file, "# Auto-generated by LED Control Overlay\n\n");
    
    // Write mode
    switch (g_settings.mode) {
        case LEDMode::Off:
            fprintf(file, "mode=off\n");
            break;
        case LEDMode::Solid:
            fprintf(file, "mode=solid\n");
            break;
        case LEDMode::Pulse:
            fprintf(file, "mode=pulse\n");
            break;
    }
    
    // Write settings
    fprintf(file, "brightness=%.2f\n", g_settings.brightness);
    fprintf(file, "pulse_interval=%lu\n", g_settings.pulseInterval);
    fprintf(file, "pulse_count=%u\n", g_settings.pulseCount);
    
    fclose(file);
    return true;
}

void triggerReload() {
    // Create reload trigger file
    FILE* file = fopen(RELOAD_TRIGGER, "w");
    if (file) {
        fclose(file);
    }
}

void applySettings() {
    saveSettings();
    triggerReload();
}

// Main GUI
class MainGui : public tsl::Gui {
private:
    std::string getModeString() {
        switch (g_settings.mode) {
            case LEDMode::Off: return "Off";
            case LEDMode::Solid: return "Solid";
            case LEDMode::Pulse: return "Pulse";
            default: return "Unknown";
        }
    }
    
    std::string getBrightnessString() {
        int percent = (int)(g_settings.brightness * 100);
        return std::to_string(percent) + "%";
    }
    
public:
    MainGui() {
        loadSettings();
    }
    
    virtual tsl::elm::Element* createUI() override {
        auto frame = new tsl::elm::OverlayFrame("LED Control", "Control notification LED");
        auto list = new tsl::elm::List();
        
        // Quick presets
        auto presetsHeader = new tsl::elm::CategoryHeader("Quick Presets");
        list->addItem(presetsHeader);
        
        auto offItem = new tsl::elm::ListItem("Turn OFF");
        offItem->setClickListener([this](u64 keys) {
            if (keys & HidNpadButton_A) {
                g_settings.mode = LEDMode::Off;
                applySettings();
                tsl::goBack();
                return true;
            }
            return false;
        });
        list->addItem(offItem);
        
        auto onFullItem = new tsl::elm::ListItem("ON - Full Brightness");
        onFullItem->setClickListener([this](u64 keys) {
            if (keys & HidNpadButton_A) {
                g_settings.mode = LEDMode::Solid;
                g_settings.brightness = 1.0f;
                applySettings();
                tsl::goBack();
                return true;
            }
            return false;
        });
        list->addItem(onFullItem);
        
        auto onDimItem = new tsl::elm::ListItem("ON - Dim (30%)");
        onDimItem->setClickListener([this](u64 keys) {
            if (keys & HidNpadButton_A) {
                g_settings.mode = LEDMode::Solid;
                g_settings.brightness = 0.3f;
                applySettings();
                tsl::goBack();
                return true;
            }
            return false;
        });
        list->addItem(onDimItem);
        
        auto pulseSlowItem = new tsl::elm::ListItem("Pulse - Slow (1s)");
        pulseSlowItem->setClickListener([this](u64 keys) {
            if (keys & HidNpadButton_A) {
                g_settings.mode = LEDMode::Pulse;
                g_settings.brightness = 1.0f;
                g_settings.pulseInterval = 1000;
                g_settings.pulseCount = 0;
                applySettings();
                tsl::goBack();
                return true;
            }
            return false;
        });
        list->addItem(pulseSlowItem);
        
        auto pulseFastItem = new tsl::elm::ListItem("Pulse - Fast (250ms)");
        pulseFastItem->setClickListener([this](u64 keys) {
            if (keys & HidNpadButton_A) {
                g_settings.mode = LEDMode::Pulse;
                g_settings.brightness = 1.0f;
                g_settings.pulseInterval = 250;
                g_settings.pulseCount = 0;
                applySettings();
                tsl::goBack();
                return true;
            }
            return false;
        });
        list->addItem(pulseFastItem);
        
        auto pulse3Item = new tsl::elm::ListItem("Pulse - 3 Times");
        pulse3Item->setClickListener([this](u64 keys) {
            if (keys & HidNpadButton_A) {
                g_settings.mode = LEDMode::Pulse;
                g_settings.brightness = 1.0f;
                g_settings.pulseInterval = 500;
                g_settings.pulseCount = 3;
                applySettings();
                tsl::goBack();
                return true;
            }
            return false;
        });
        list->addItem(pulse3Item);
        
        // Current settings display
        auto currentHeader = new tsl::elm::CategoryHeader("Current Settings");
        list->addItem(currentHeader);
        
        auto modeItem = new tsl::elm::ListItem("Mode");
        modeItem->setValue(getModeString());
        list->addItem(modeItem);
        
        auto brightnessItem = new tsl::elm::ListItem("Brightness");
        brightnessItem->setValue(getBrightnessString());
        list->addItem(brightnessItem);
        
        if (g_settings.mode == LEDMode::Pulse) {
            auto intervalItem = new tsl::elm::ListItem("Pulse Interval");
            intervalItem->setValue(std::to_string(g_settings.pulseInterval) + "ms");
            list->addItem(intervalItem);
            
            auto countItem = new tsl::elm::ListItem("Pulse Count");
            countItem->setValue(g_settings.pulseCount == 0 ? "Infinite" : std::to_string(g_settings.pulseCount));
            list->addItem(countItem);
        }
        
        // Advanced settings
        auto advancedHeader = new tsl::elm::CategoryHeader("Advanced");
        list->addItem(advancedHeader);
        
        auto customItem = new tsl::elm::ListItem("Custom Settings →");
        customItem->setClickListener([this](u64 keys) {
            if (keys & HidNpadButton_A) {
                tsl::changeTo<CustomGui>();
                return true;
            }
            return false;
        });
        list->addItem(customItem);
        
        frame->setContent(list);
        return frame;
    }
};

// Custom settings GUI
class CustomGui : public tsl::Gui {
public:
    CustomGui() { }
    
    virtual tsl::elm::Element* createUI() override {
        auto frame = new tsl::elm::OverlayFrame("LED Control", "Custom Settings");
        auto list = new tsl::elm::List();
        
        // Mode selection
        auto modeHeader = new tsl::elm::CategoryHeader("Mode");
        list->addItem(modeHeader);
        
        auto modeOffItem = new tsl::elm::ListItem("Off");
        modeOffItem->setClickListener([](u64 keys) {
            if (keys & HidNpadButton_A) {
                g_settings.mode = LEDMode::Off;
                return true;
            }
            return false;
        });
        if (g_settings.mode == LEDMode::Off) {
            modeOffItem->setValue("✓");
        }
        list->addItem(modeOffItem);
        
        auto modeSolidItem = new tsl::elm::ListItem("Solid");
        modeSolidItem->setClickListener([](u64 keys) {
            if (keys & HidNpadButton_A) {
                g_settings.mode = LEDMode::Solid;
                return true;
            }
            return false;
        });
        if (g_settings.mode == LEDMode::Solid) {
            modeSolidItem->setValue("✓");
        }
        list->addItem(modeSolidItem);
        
        auto modePulseItem = new tsl::elm::ListItem("Pulse");
        modePulseItem->setClickListener([](u64 keys) {
            if (keys & HidNpadButton_A) {
                g_settings.mode = LEDMode::Pulse;
                return true;
            }
            return false;
        });
        if (g_settings.mode == LEDMode::Pulse) {
            modePulseItem->setValue("✓");
        }
        list->addItem(modePulseItem);
        
        // Brightness
        auto brightnessHeader = new tsl::elm::CategoryHeader("Brightness");
        list->addItem(brightnessHeader);
        
        auto brightness25 = new tsl::elm::ListItem("25%");
        brightness25->setClickListener([](u64 keys) {
            if (keys & HidNpadButton_A) {
                g_settings.brightness = 0.25f;
                return true;
            }
            return false;
        });
        list->addItem(brightness25);
        
        auto brightness50 = new tsl::elm::ListItem("50%");
        brightness50->setClickListener([](u64 keys) {
            if (keys & HidNpadButton_A) {
                g_settings.brightness = 0.5f;
                return true;
            }
            return false;
        });
        list->addItem(brightness50);
        
        auto brightness75 = new tsl::elm::ListItem("75%");
        brightness75->setClickListener([](u64 keys) {
            if (keys & HidNpadButton_A) {
                g_settings.brightness = 0.75f;
                return true;
            }
            return false;
        });
        list->addItem(brightness75);
        
        auto brightness100 = new tsl::elm::ListItem("100%");
        brightness100->setClickListener([](u64 keys) {
            if (keys & HidNpadButton_A) {
                g_settings.brightness = 1.0f;
                return true;
            }
            return false;
        });
        list->addItem(brightness100);
        
        // Pulse settings (if pulse mode)
        if (g_settings.mode == LEDMode::Pulse) {
            auto pulseHeader = new tsl::elm::CategoryHeader("Pulse Interval");
            list->addItem(pulseHeader);
            
            auto interval250 = new tsl::elm::ListItem("250ms (Very Fast)");
            interval250->setClickListener([](u64 keys) {
                if (keys & HidNpadButton_A) {
                    g_settings.pulseInterval = 250;
                    return true;
                }
                return false;
            });
            list->addItem(interval250);
            
            auto interval500 = new tsl::elm::ListItem("500ms (Fast)");
            interval500->setClickListener([](u64 keys) {
                if (keys & HidNpadButton_A) {
                    g_settings.pulseInterval = 500;
                    return true;
                }
                return false;
            });
            list->addItem(interval500);
            
            auto interval1000 = new tsl::elm::ListItem("1000ms (Normal)");
            interval1000->setClickListener([](u64 keys) {
                if (keys & HidNpadButton_A) {
                    g_settings.pulseInterval = 1000;
                    return true;
                }
                return false;
            });
            list->addItem(interval1000);
            
            auto interval2000 = new tsl::elm::ListItem("2000ms (Slow)");
            interval2000->setClickListener([](u64 keys) {
                if (keys & HidNpadButton_A) {
                    g_settings.pulseInterval = 2000;
                    return true;
                }
                return false;
            });
            list->addItem(interval2000);
        }
        
        // Apply button
        auto applyHeader = new tsl::elm::CategoryHeader("");
        list->addItem(applyHeader);
        
        auto applyItem = new tsl::elm::ListItem("Apply Settings");
        applyItem->setClickListener([](u64 keys) {
            if (keys & HidNpadButton_A) {
                applySettings();
                tsl::goBack();
                tsl::goBack();
                return true;
            }
            return false;
        });
        list->addItem(applyItem);
        
        frame->setContent(list);
        return frame;
    }
};

// Overlay class
class LEDOverlay : public tsl::Overlay {
public:
    virtual void initServices() override {
        fsdevMountSdmc();
    }
    
    virtual void exitServices() override {
        fsdevUnmountAll();
    }
    
    virtual void onShow() override { }
    virtual void onHide() override { }
    
    virtual std::unique_ptr<tsl::Gui> loadInitialGui() override {
        return initially<MainGui>();
    }
};

int main(int argc, char* argv[]) {
    return tsl::loop<LEDOverlay>(argc, argv);
}
